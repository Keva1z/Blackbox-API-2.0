from typing import TYPE_CHECKING, Optional, Dict, Any, Tuple
from blackbox.models import AgentMode, Model, Chat, Models
from blackbox.image import ImageTool
import requests
import aiohttp
from blackbox.exceptions import APIRequestError
import re
import asyncio
import time
import socket

if TYPE_CHECKING:
    from blackbox.client import AIClient

class CompletionPayload:
    def __init__(self, client: "AIClient"):
        self.client = client
        self.language_prompt = "Reply only in the language in which I asked the question"

    def _get_chat(self, agent: Optional[AgentMode]) -> Chat:
        if self.client.chat_history:
            return self.client.database.get_or_create_chat(self.client.database, agent.id if agent else "default")
        return Chat(self.client.database)

    async def _get_chat_async(self, agent: Optional[AgentMode]) -> Chat:
        if self.client.chat_history:
            return await self.client.database.get_or_create_chat_async(self.client.database, agent.id if agent else "default")
        return Chat(self.client.database)

    def generate(
            self,
            message: str,
            agent: Optional[AgentMode],
            model: Model,
            max_tokens: int,
            image: Optional[str] = None
        ) -> Tuple[Dict[str, Any], Chat]:
        chat = self._get_chat(agent)
        chat.add_message(self.language_prompt + "\n\n" + message, "user", image)

        validated_value = self.client.validation.fetch_validated()
        payload, chat = self._get_payload(chat, validated_value, agent, model, max_tokens, image)
        return payload, chat

    async def generate_async(
            self,
            message: str,
            agent: Optional[AgentMode],
            model: Model,
            max_tokens: int,
            image: Optional[str] = None
        ) -> Tuple[Dict[str, Any], Chat]:
        chat = await self._get_chat_async(agent)
        await chat.add_message_async(self.language_prompt + "\n\n" + message, "user", image)

        validated_value = await self.client.validation.fetch_validated_async()

        payload, chat = self._get_payload(chat, validated_value, agent, model, max_tokens, image)
        return payload, chat

    def _get_payload(self,
                     chat: Chat,
                     validated_value: str,
                     agent: Optional[AgentMode],
                     model: Model,
                     max_tokens: int,
                     image: Optional[str] = None) -> Dict[str, Any]:
        
        payload = {
            "messages": [m.to_dict() for m in chat.get_messages()],
            "id": chat.chat_id,
            "previewToken": None,
            "userId": None,
            "codeModelMode": True,
            "agentMode": agent.to_dict() if agent else {},
            "trendingAgentMode": {},
            "isMicMode": False,
            "maxTokens": max_tokens,
            "playgroundTopP": None,
            "playgroundTemperature": None,
            "isChromeExt": False,
            "githubToken": "",
            "clickedAnswer2": False,
            "clickedAnswer3": False,
            "clickedForceWebSearch": False,
            "visitFromDelta": False,
            "mobileClient": False,
            "userSelectedModel": None,
            "validated": validated_value,
            "imageGenerationMode": False,
            "webSearchModePrompt": False
        }

        if image is None and not agent and model != Models.BLACKBOX:
            payload["userSelectedModel"] = model.id
        
        # Update referer header based on agent mode
        self.client.headers["referer"] = (
            f"https://www.blackbox.ai/agent/{agent.id}"
            if agent else
            "https://www.blackbox.ai/chat"
        )

        return payload, chat

class Completions:


    def __init__(self, client: "AIClient"):
        self.client = client
        self.completion_payload = CompletionPayload(self.client)

    def _process_response(self, response_text: str) -> str:
        """Process and clean the API response text.
        
        Args:
            response_text (str): Raw response text
            
        Returns:
            str: Cleaned response text
        """
        self.client._log("Processing API response", "DEBUG")
        # Удаляем специальные маркеры
        cleaned_text = re.sub(r'\$~~~\$.*?\$~~~\$', '', response_text, flags=re.DOTALL)
        cleaned_text = re.sub(r'Generated by BLACKBOX\.AI, try unlimited chat https://www\.blackbox\.ai\n\n?', '', cleaned_text)
        return cleaned_text
    
    async def get_response(self, url: str, payload: Dict[str, Any], chat: Chat, synchronous: bool = False):
        async with aiohttp.ClientSession(headers=self.client.headers) as session:
            async with session.post(url, json=payload) as response:
                self.client._log(f"Received {'synchronous' if synchronous else 'asynchronous'} response from {url}", "RESPONSE")
                if response.status != 200:
                    raise APIRequestError(f"Failed to create chat: {response.status} {await response.text()}")

                try:
                    full_response = ""
                    
                    while True:
                        try:
                            chunk = await asyncio.wait_for(
                                response.content.read(1024),
                                timeout=1.0
                            )
                            if not chunk:
                                break
                            
                            full_response += chunk.decode('utf-8')
                            
                        except asyncio.TimeoutError:
                            break
                    
                    processed_response = self._process_response(full_response)
                    await chat.add_message_async(processed_response, "assistant")
                    return processed_response
                    
                except Exception as e:
                    raise APIRequestError(f"Failed to process response: {str(e)}")

    def generate(self, message: str,
               agent: Optional[AgentMode],
               model: Model,
               max_tokens: int,
               image: Optional[str] = None):
        
        url = f"{self.client.base_url}/api/chat"
        if image is not None:
            image = ImageTool.image_to_base64(image)

        payload, chat = self.completion_payload.generate(message, agent, model, max_tokens, image)

        self.client._log(f"Sending synchronous request to {url}", "REQUEST")

        return asyncio.run(self.get_response(url, payload, chat, synchronous=True))

    async def generate_async(self, message: str,
               agent: Optional[AgentMode],
               model: Model,
               max_tokens: int,
               image: Optional[str] = None):
        
        url = f"{self.client.base_url}/api/chat"
        if image is not None:
            image = ImageTool.image_to_base64(image)

        payload, chat = await self.completion_payload.generate_async(message, agent, model, max_tokens, image)

        self.client._log(f"Sending asynchronous request to {url}", "REQUEST")

        return await self.get_response(url, payload, chat, synchronous=False)

